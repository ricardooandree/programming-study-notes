<font color="#7f7f7f"><em>Friday, 27-09-2024 - 16:11</em></font>
#programming #dsa 

> [!Summary] Main page for DSA course of Helsinki University

# Syllabus
### [[01 - Introduction]]
- What is an algorithm?
- What is a data structure?
- Implementing an algorithm
- Efficiency of algorithms
- Analysis of algorithms

### [[02 - List]]
- List in memory
- List operations
- References and copying
- Lists in other languages

### [[03 - Efficient Algorithms]]
- Outline of an efficient algorithm
- Example: Stock trading
- Is the algorithm correct?
- Example: Bit string
- Example: List splitting
- Example: Sub-lists

### [[04 - Hashing]]
- Set
- Example: How many numbers?
- Dictionary
- Example: Mode
- Example: Rounds
- Example: Playlist
- Example: List sums
- How does hashing work?
- Hashing in other languages

### [[05 - Sorting]]
- Sorting in Python
- Example: Smallest difference
- Hashing vs. Sorting
- More about sorting
- Example: Restaurant
- How is sorting done?
- Sorting in other languages

### [[06 - Own Data Structures]]
- Example: Stack
- How not to implement a class
- Additional class features
- Example: Efficient duplicates
- Example: Mode

### [[07 - Trees and Recursion]]
- Implementing a tree
- Computing information from a tree
- Computing depths
- Improving the class
- Example: Employees
- Example: Queens

### [[08 - Graph Algorithms]]
- Programming with graphs
- Depth-first search (DFS)
- Components and connectivity
- Breadth-first search (BFS)
- Shortest paths and distances
- Labyrinth as a graph

### [[09 - Search Problems]]
- Iterating solutions
- Example: Orderings
- Example: Balanced parenthesis
- Speeding up the search
- Greedy algorithms
- Why the algorithm is correct?
- Algorithm checking

### [[10 - Dynamic Programming]]
- Finding the optimal solution
- Constructing an optimal solution
- Counting solutions
- Example: Subsequence's
- Example: Balanced parenthesis
- Nested recursion

### [[11 - More Data Structures]]
- Deque
- Stack and Queue
- Heap
- Example: Sliding window
- Other programming languages

### [[12 - Binary Search Tree]]
- Set as a binary tree
- Implementation in Python
- Balanced trees
- Example: Hotel
- Why not in Python?
- Other Programming languages

### [[13 - Directed Graphs]]
- Representing directed graphs
- Topological ordering
- Dynamic programming
- Strong connectivity

### [[14 - Shortest Paths]]
- Bellman-Ford algorithm
- Dijkstra's algorithm
- Constructing shortest paths
- Floyd-Warshall algorithm
- Choice of algorithm

### [[15 - Components and Spanning Trees]]
- Union-find data structure
- Example: New roads
- Trees in graphs
- Kruskal's algorithm
- Minimizing vs. Maximizing

### [[16 - Maximum Flow]]
- Ford-Fulkerson algorithm
- Minimum cut
- Example: Prison escape
- Choosing augmenting paths
- Maximum matching
- Example: Ball

---
### Exercises
##### Week 1
- Candies
- Inversions
- Same bits
- Repeat
- Efficiency test
- Sequence of numbers
- Time complexities
- Rectangles

##### Week 2
- List efficiency I
- List efficiency II
- List incrementing
- Different sums
- Circle game
- Two lists
- Nested list
- Inversions again

##### Week 3
- Same bit
- Same character
- Forbidden character
- Lone number
- List split
- Tira sequences
- Last number
- Stock trading

##### Week 4
- Robot route
- No pair
- Same distance
- Playlists
- Big win
- Same hash
- Sub-lists
- Long route

##### Week 5
- Packing
- Contiguous numbers
- Sorting algorithms
- Binary search
- Largest distance
- Restaurant
- Semi-sorting
- Swap and move

##### Week 6
- Max list
- Repeat list
- Fast mode
- Mex numbers
- Quick list
- Different repeats
- Sum of squares
- Near list

##### Week 7
- Leaves
- No branch
- Children
- Depths
- Same depth
- Subtrees
- Queens
- All Trees

##### Week 8
- End of course
- Components
- Cities
- Computer network
- Chambers
- Labyrinth
- Colouring
- Push box

##### Week 9
- Choice of sum
- Subsets
- Balanced parenthesis
- Anagrams
- Odd lists
- Fast coins
- Not adjacent
- More coins

##### Week 10
- Most coins
- Subsequence construction
- Efficiency of a formula
- All subsequence's
- Removing recursion
- Smallest count
- Bit erase Course

##### Week 11
- Changing list
- Efficiency of deque
- Smallest on a list
- Smallest elements
- Flip list
- Median
- Full round
- Small sums

##### Week 12
- Set size
- Tree height
- Order of addition
- Min and max
- Previous and next
- Remove an element
- Many elements
- AVL tree

##### Week 13
- Topological ordering
- Strong connectivity
- Course plan
- Number of paths
- Airports
- All paths
- Graph game
- Paths

##### Week 14
- Bellmanâ€“Ford algorithm
- Dijkstra's algorithm
- Best route
- Train prices
- List jump
- Grid path
- Wall breaking
- Measuring water

##### Week 15
- Minimum spanning tree
- Maximum spanning tree
- Components
- New Roads
- Largest set
- Same weight
- Walls and floors
- All trees

##### Week 16
- End of course
- Maximum flow
- Download
- Planets
- Ball
- Knight pairs
- New walls
- Coin grid

### References
[DSA Course Page](https://tira.mooc.fi/spring-2024/)
[Exercises Page](https://cses.fi/dsa24k/list/)
